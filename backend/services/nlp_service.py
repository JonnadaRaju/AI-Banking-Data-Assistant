import re
import time
import logging
import openai
from openai import OpenAI

from backend.config import (
    OPENROUTER_API_KEY,
    OPENROUTER_MODEL,
    OPENAI_BASE_URL,
    MAX_RETRIES,
    OPENAI_REQUEST_TIMEOUT_SECONDS,
    RETRY_DELAY,
)
from backend.services.validator import clean_sql

logger = logging.getLogger(__name__)

# BUG FIX: added fallback chain — if primary model fails (rate limit / not available),
# automatically tries next model instead of crashing
FREE_MODEL_FALLBACKS = [
    OPENROUTER_MODEL,                               # from .env (primary)
    "meta-llama/llama-3.3-70b-instruct:free",
    "deepseek/deepseek-r1-distill-llama-70b:free",
    "google/gemma-3-27b-it:free",
    "qwen/qwen3-14b:free",
    "mistralai/mistral-7b-instruct:free",
]

DB_SCHEMA = """
CREATE TABLE customers (
    customer_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT,
    phone TEXT,
    address TEXT,
    created_at TIMESTAMP
);

CREATE TABLE accounts (
    account_id INTEGER PRIMARY KEY,
    customer_id INTEGER,
    account_number TEXT,
    account_type TEXT,
    balance NUMERIC,
    created_at TIMESTAMP,
    FOREIGN KEY(customer_id) REFERENCES customers(customer_id)
);

CREATE TABLE transactions (
    transaction_id INTEGER PRIMARY KEY,
    account_id INTEGER,
    amount NUMERIC,
    transaction_type TEXT,
    description TEXT,
    transaction_date TIMESTAMP,
    FOREIGN KEY(account_id) REFERENCES accounts(account_id)
);
"""


def build_prompt(user_query: str) -> str:
    return f"""You are an expert SQL generator for a PostgreSQL banking database.

Database schema:
{DB_SCHEMA}

Rules:
- Generate ONLY a single SELECT query
- Use PostgreSQL syntax only
- For today use: CURRENT_DATE
- For this week use: CURRENT_DATE - INTERVAL '7 days'
- Use aliases: c for customers, a for accounts, t for transactions
- Return ONLY the SQL query, no explanation, no markdown, no backticks

Question: {user_query}"""


def query_to_sql(user_query: str) -> str:
    prompt = build_prompt(user_query)

    client = OpenAI(
        api_key=OPENROUTER_API_KEY,
        base_url=OPENAI_BASE_URL,
        timeout=OPENAI_REQUEST_TIMEOUT_SECONDS,
        max_retries=0,
    )

    # Deduplicate while preserving order
    seen = []
    models_to_try = []
    for m in FREE_MODEL_FALLBACKS:
        if m and m not in seen:
            seen.append(m)
            models_to_try.append(m)

    last_error = None

    for model in models_to_try:
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                logger.info(f"Trying model: {model} (attempt {attempt}/{MAX_RETRIES})")
                result = client.chat.completions.create(
                    model=model,
                    messages=[
                        {"role": "system", "content": "Generate one safe PostgreSQL SELECT query only."},
                        {"role": "user", "content": prompt},
                    ],
                    max_tokens=300,
                    temperature=0.1,
                )
                content = ""
                if result and result.choices:
                    content = result.choices[0].message.content or ""

                raw_sql = _extract_sql(content)
                if not raw_sql:
                    raise Exception("AI model returned an empty response.")

                sql = clean_sql(raw_sql)
                logger.info(f"SQL generated by {model}: {sql}")
                return sql

            except openai.APIStatusError as e:
                status = e.status_code
                msg = str(e).lower()
                last_error = e

                # Model not available / not subscribed → skip to next model immediately
                if status in (400, 403, 404) and any(
                    kw in msg for kw in ["non-subscribed", "no endpoints", "unable to access", "not found"]
                ):
                    logger.warning(f"Model {model} unavailable (HTTP {status}), trying next model...")
                    break  # break inner retry loop, try next model

                # Rate limited → wait and retry same model, then move on
                if status == 429:
                    if attempt < MAX_RETRIES:
                        logger.warning(f"Rate limit on {model}, waiting {RETRY_DELAY}s...")
                        time.sleep(RETRY_DELAY)
                        continue
                    logger.warning(f"Rate limit exhausted on {model}, trying next model...")
                    break

                # Other API errors → retry a couple times then move on
                if attempt < MAX_RETRIES:
                    time.sleep(5)
                    continue
                logger.warning(f"API error on {model}: {str(e)[:100]}, trying next model...")
                break

            except openai.AuthenticationError:
                raise Exception("Invalid OpenRouter API key. Check your .env file.")

            except openai.APIConnectionError:
                raise Exception("Cannot connect to OpenRouter API. Check your internet connection.")

            except (openai.APITimeoutError, TimeoutError):
                last_error = Exception("Request timed out.")
                if attempt < MAX_RETRIES:
                    time.sleep(5)
                    continue
                logger.warning(f"Timeout on {model}, trying next model...")
                break

            except Exception as e:
                last_error = e
                if attempt < MAX_RETRIES:
                    time.sleep(5)
                    continue
                break

    error_msg = str(last_error)[:200] if last_error else "unknown error"
    raise Exception(f"All AI models are currently unavailable. Last error: {error_msg}. Please try again in a minute.")


def _extract_sql(response: str) -> str:
    try:
        if not response:
            return ""
        text = str(response).strip()
        match = re.search(r"```(?:sql)?\s*(.*?)```", text, re.DOTALL | re.IGNORECASE)
        if match:
            text = match.group(1).strip()
        select_idx = text.upper().rfind("SELECT")
        if select_idx != -1:
            text = text[select_idx:]
        return text.strip()
    except Exception as e:
        logger.error(f"Failed to parse response: {e}")
        return ""